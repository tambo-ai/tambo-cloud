declare module "hydra-ai-react" {
  import { type ComponentType, type ReactNode } from "react";
  import { z } from "zod";

  // State Management Types
  export function useHydraMessage<T>(): [T, (updates: Partial<T>) => void];

  export interface HydraMessageProviderProps {
    messageId: string;
    initialProps?: Record<string, any>;
    children: ReactNode;
  }

  export const HydraMessageProvider: React.FC<HydraMessageProviderProps>;

  // Component State Hook
  export function useHydraMessageState<T extends Record<string, any>>(
    messageId: string,
  ): {
    state: T;
    setState: (updates: Partial<T>) => void;
  };

  // Tool Registry Types
  export interface ToolDefinition<T extends z.ZodSchema> {
    description: string;
    inputSchema: T;
  }

  export type ToolImplementation<T extends z.ZodSchema> = (
    input: z.infer<T>,
  ) => Promise<unknown>;

  export interface ToolRegistry<
    T extends Record<string, ToolDefinition<z.ZodSchema>>,
  > {
    tools: T;
    registerTool<K extends keyof T>(
      name: K,
      implementation: ToolImplementation<T[K]["inputSchema"]>,
    ): void;
  }

  export function createToolRegistry<
    T extends Record<string, ToolDefinition<z.ZodSchema>>,
  >(config: T): ToolRegistry<T>;

  // Component Registry Types
  export interface ComponentDefinition<
    T extends Record<string, ToolDefinition<z.ZodSchema>>,
  > {
    component: ComponentType<any>;
    propsSchema: z.ZodSchema;
    description?: string;
    associatedTools: Array<keyof T>;
  }

  export interface ComponentRegistry<
    T extends Record<string, ToolDefinition<z.ZodSchema>>,
  > {
    components: Record<string, ComponentDefinition<T>>;
  }

  export function createComponentRegistry<
    T extends Record<string, ToolDefinition<z.ZodSchema>>,
  >(config: Record<string, ComponentDefinition<T>>): ComponentRegistry<T>;

  // Hydra Config Types
  export interface HydraInitConfig<
    T extends Record<string, ToolDefinition<z.ZodSchema>>,
  > {
    apiKey: string;
    toolRegistry: ToolRegistry<T>;
    componentRegistry: ComponentRegistry<T>;
    systemMessage?: string;
    prompt?: string;
  }

  // Hook Types
  export function useTool<
    T extends Record<string, ToolDefinition<z.ZodSchema>>,
    K extends keyof T,
  >(name: K): ToolImplementation<T[K]["inputSchema"]>;

  // Provider Types
  export interface HydraProviderProps {
    hydraInstance: HydraInitConfig<any>;
    children: ReactNode;
  }

  export const HydraProvider: React.FC<HydraProviderProps>;

  // Thread types
  export interface HydraThread {
    id: string;
    title: string; // Defaults to "New Thread", auto-updated by AI after first response
    contextId?: string;
    isAutoTitle?: boolean; // Indicates if title should be auto-generated by AI
    userProfile?: string; // User profile information
  }

  export interface HydraAIProcessStatus {
    state: "evaluating" | "tools" | "generating";
    message: string;
  }

  export interface HydraStreamingState {
    isStreaming: boolean;
    isComplete: boolean;
  }

  export interface HydraComponentState {
    component: ComponentType<any>;
    generatedProps: Record<string, any>;
    interactiveProps: Record<string, any>;
  }

  // Simplified suggestion types
  export interface HydraSuggestion {
    title: string;
    detailedSuggestion: string;
    suggestedTools?: string[];
    components?: string[];
  }

  export interface ThreadMessageOptions {
    suggestion?: HydraSuggestion; // Include the suggestion being acted upon
    autoTitle?: boolean; // Whether to auto-generate title
  }

  export interface HydraThreadMessage {
    role: "user" | "ai";
    message: string;
    aiStatus?: HydraAIProcessStatus[];
    streamingState?: Record<string, HydraStreamingState>;
    generatedComponent?: HydraComponentState;
    interactedComponent?: HydraComponentState | null;
    suggestions?: HydraSuggestion[];
    selectedSuggestion?: HydraSuggestion; // Track which suggestion was selected
  }

  export interface HydraThreadState {
    messages: HydraThreadMessage[];
    contextId?: string; // Optional user-provided context identifier
  }

  // Core operations type
  export interface ThreadOperations {
    send: (
      threadId: string,
      message: string,
      options?: ThreadMessageOptions,
    ) => Promise<void>;
    update: (threadId: string, updates: Partial<HydraThread>) => Promise<void>;
    delete: (threadId: string) => Promise<void>;
    archive: (threadId: string) => Promise<void>;
    clear: (threadId: string) => Promise<void>;
    create: (
      title?: string,
      contextId?: string,
      options?: {
        isAutoTitle?: boolean;
        userProfile?: string;
      },
    ) => Promise<string>;
  }

  // Core state type
  export interface ThreadState {
    threads: HydraThread[];
    threadState: Record<string, HydraThreadState>;
    getByContext: (contextId: string) => HydraThread[];
  }

  // Core hook return type
  export interface ThreadCore {
    operations: ThreadOperations;
    state: ThreadState;
  }

  // Specialized hook return types
  export interface ThreadMessages {
    send: (message: string, options?: ThreadMessageOptions) => Promise<void>;
    clear: () => Promise<void>;
    messages: HydraThreadMessage[];
  }

  export interface ThreadComponent {
    updateProps: (updates: Record<string, any>) => void;
    component: ComponentType<any>;
    props: Record<string, any>;
  }

  // Core hook
  export function useThreadCore(): ThreadCore;

  // Individual hooks (granular control)
  export function useThreads(): HydraThread[];
  export function useThreadState(): Record<string, HydraThreadState>;
  export function useCreateThread(): (
    title?: string,
    contextId?: string,
  ) => Promise<string>;
  export function useDeleteThread(): (threadId: string) => Promise<void>;
  export function useUpdateThread(): (
    threadId: string,
    updates: Partial<HydraThread>,
  ) => Promise<void>;
  export function useSendThreadMessage(): (
    threadId: string,
    message: string,
    options?: ThreadMessageOptions,
  ) => Promise<void>;
  export function useGetThreadsByContext(): (
    contextId: string,
  ) => HydraThread[];
  export function useClearThreadMessages(): (threadId: string) => Promise<void>;
  export function useArchiveThread(): (threadId: string) => Promise<void>;

  // Configuration hooks
  export function useUpdateSystemMessage(): (message: string) => Promise<void>;
  export function useUpdatePrompt(): (prompt: string) => Promise<void>;
  export function useSystemConfig(): {
    systemMessage: string | undefined;
    prompt: string | undefined;
    updateSystemMessage: (message: string) => Promise<void>;
    updatePrompt: (prompt: string) => Promise<void>;
  };

  // Specialized hooks (common patterns)
  export function useThreadMessages(threadId: string): ThreadMessages;
  export function useThreadComponent(messageId: string): ThreadComponent;

  // Suggestion handling types
  export interface SuggestionHandlers {
    accept: (suggestion: HydraSuggestion) => Promise<void>;
    dismiss: (suggestion: HydraSuggestion) => Promise<void>;
    getSuggestions: () => HydraSuggestion[];
  }

  // Add specialized suggestion hook
  export function useThreadSuggestions(threadId: string): {
    suggestions: HydraSuggestion[];
    accept: (suggestion: HydraSuggestion) => Promise<void>;
    dismiss: (suggestion: HydraSuggestion) => Promise<void>;
  };

  export interface HydraContext {
    config: HydraInitConfig<any>;
    updateSystemMessage: (message: string) => Promise<void>;
    updatePrompt: (prompt: string) => Promise<void>;
  }

  export function useHydraContext(): HydraContext | null;

  // Profile Management
  export interface StoredProfile {
    userId: string;
    profile: string;
    updatedAt: string;
  }

  export interface ProfileOperations {
    getProfile: (userId: string) => Promise<StoredProfile | null>;
    updateProfile: (userId: string, profile: string) => Promise<void>;
    deleteProfile: (userId: string) => Promise<void>;
    listProfiles: () => Promise<StoredProfile[]>;
  }

  // Profile hooks
  export function useProfile(userId: string): {
    profile: StoredProfile | null;
    isLoading: boolean;
    error: Error | null;
    updateProfile: (profile: string) => Promise<void>;
    deleteProfile: () => Promise<void>;
  };

  export function useProfileOperations(): ProfileOperations;

  export function useProfiles(): {
    profiles: StoredProfile[];
    isLoading: boolean;
    error: Error | null;
    refresh: () => Promise<void>;
  };
}
