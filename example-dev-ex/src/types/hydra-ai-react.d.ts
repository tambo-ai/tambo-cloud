declare module "hydra-ai-react" {
  import { type ComponentType, type ReactNode } from "react";
  import { z } from "zod";

  // State Management Types
  export function useHydraMessage<T>(): [T, (updates: Partial<T>) => void];

  // Add HydraSuggestion type
  export interface HydraSuggestion {
    title: string;
    detailedSuggestion: string;
    suggestedTools?: string[];
    components?: string[];
  }

  export interface HydraMessageProviderProps
    extends Readonly<{
      messageId: string;
      initialProps?: Record<string, any>;
      children: ReactNode;
    }> {}

  export const HydraMessageProvider: React.FC<HydraMessageProviderProps>;

  // Component State Hook
  export function useHydraMessageState<T extends Record<string, any>>(
    messageId: string,
  ): {
    state: T;
    setState: (updates: Partial<T>) => void;
  };

  // Tool Registry Types
  export interface HydraToolDefinition<T extends z.ZodSchema> {
    description: string;
    inputSchema: T;
  }

  export type HydraToolImplementation<T extends z.ZodSchema> = (
    input: z.infer<T>,
  ) => Promise<unknown>;

  export interface HydraToolRegistry<
    T extends Record<string, HydraToolDefinition<z.ZodSchema>>,
  > {
    tools: T;
    registerTool<K extends keyof T>(
      name: K,
      implementation: HydraToolImplementation<T[K]["inputSchema"]>,
    ): void;
  }

  export function createHydraToolRegistry<
    T extends Record<string, HydraToolDefinition<z.ZodSchema>>,
  >(config: T): HydraToolRegistry<T>;

  // Component Registry Types
  export interface HydraComponentDefinition<
    T extends Record<string, HydraToolDefinition<z.ZodSchema>>,
  > {
    component: ComponentType<any>;
    propsSchema: z.ZodSchema;
    description?: string;
    associatedTools: Array<keyof T>;
  }

  export interface HydraComponentRegistry<
    T extends Record<string, HydraToolDefinition<z.ZodSchema>>,
  > {
    components: Record<string, HydraComponentDefinition<T>>;
  }

  export function createHydraComponentRegistry<
    T extends Record<string, HydraToolDefinition<z.ZodSchema>>,
  >(
    config: Record<string, HydraComponentDefinition<T>>,
  ): HydraComponentRegistry<T>;

  // Hydra Config Types
  export interface HydraInitConfig<
    T extends Record<string, HydraToolDefinition<z.ZodSchema>>,
  > {
    apiKey: string;
    toolRegistry: HydraToolRegistry<T>;
    componentRegistry: HydraComponentRegistry<T>;
    personality: HydraPersonality;
    systemMessage?: string;
    prompt?: string;
  }

  // Hook Types
  export function useTool<
    T extends Record<string, HydraToolDefinition<z.ZodSchema>>,
    K extends keyof T,
  >(name: K): HydraToolImplementation<T[K]["inputSchema"]>;

  // Provider Types
  export interface HydraProviderProps
    extends Readonly<{
      hydraInstance: HydraInitConfig<any>;
      children: ReactNode;
    }> {}

  export const HydraProvider: React.FC<HydraProviderProps>;

  // Thread types
  export interface HydraThread {
    id: string;
    title: string; // Defaults to "New Thread", auto-updated by AI after first response
    contextId?: string;
    isAutoTitle?: boolean; // Indicates if title should be auto-generated by AI
    userProfile?: string; // User profile information
  }

  export interface HydraAIProcessStatus {
    state: "evaluating" | "tools" | "generating";
    message: string;
  }

  export interface HydraStreamingState {
    isStreaming: boolean;
    isComplete: boolean;
  }

  export interface HydraComponentState {
    component: ComponentType<any>;
    generatedProps: Record<string, any>;
    interactiveProps: Record<string, any>;
  }

  export interface HydraThreadMessage {
    // Core required props
    type: "user" | "hydra";
    content: string;
    isStreaming?: boolean;
    hasInteraction?: boolean;
    status?: HydraProcessStatus[];
    streamState?: HydraStreamState;
    generatedComponent?: HydraComponent;
    interactiveComponent?: HydraComponent | null;

    suggestions?: HydraSuggestion[];
    selectedSuggestion?: HydraSuggestion;
  }

  export interface HydraThreadState {
    messages: HydraThreadMessage[];
    contextId?: string; // Optional user-provided context identifier
  }

  // Core operations type
  export interface ThreadOperations {
    generate: (
      threadId: string,
      message: string,
      options?: ThreadMessageOptions,
    ) => Promise<void>;
    update: (threadId: string, updates: Partial<HydraThread>) => Promise<void>;
    delete: (threadId: string) => Promise<void>;
    archive: (threadId: string) => Promise<void>;
    clear: (threadId: string) => Promise<void>;
    create: (
      title?: string,
      contextId?: string,
      options?: {
        isAutoTitle?: boolean;
        userProfile?: string;
      },
    ) => Promise<string>;
  }

  // Core state type
  export interface ThreadState {
    threads: HydraThread[];
    threadState: Record<string, HydraThreadState>;
    getByContext: (contextId: string) => HydraThread[];
  }

  // Core hook return type
  export interface ThreadCore {
    operations: ThreadOperations;
    state: ThreadState;
  }

  export interface ThreadMessageOptions {
    stream?: boolean;
    abortSignal?: AbortSignal;
    onProgress?: (message: Partial<HydraThreadMessage>) => void;
    onError?: (error: Error) => void;
    onFinish?: (message: HydraThreadMessage) => void;
  }

  // Specialized hook return types
  export interface ThreadMessages {
    messages: HydraThreadMessage[];
    input: string;
    isLoading: boolean;
    isStreaming: boolean;
    error?: Error;
    handleInputChange: (value: string) => void;
    handleSubmit: (
      messageOrEvent: string | React.FormEvent,
      options?: ThreadMessageOptions,
    ) => Promise<HydraThreadMessage>;
    clear: () => Promise<void>;
    reset: () => void;
    abort: () => void;
  }

  export interface ThreadComponent {
    updateProps: (updates: Record<string, any>) => void;
    component: ComponentType<any>;
    props: Record<string, any>;
  }

  // Core hook
  export function useHydraThreadCore(): HydraThreadCore;

  // Individual hooks (granular control)
  export function useHydraThreads(): HydraThread[];
  export function useHydraThreadState(): Record<string, HydraThreadState>;
  export function useHydraCreateThread(): (
    title?: string,
    contextId?: string,
  ) => Promise<string>;
  export function useHydraDeleteThread(): (threadId: string) => Promise<void>;
  export function useHydraUpdateThread(): (
    threadId: string,
    updates: Partial<HydraThread>,
  ) => Promise<void>;
  export function useHydraGenerateThreadMessage(): (
    threadId: string,
    message: string,
    options?: HydraThreadMessageOptions,
  ) => Promise<void>;
  export function useHydraGetThreadsByContext(): (
    contextId: string,
  ) => HydraThread[];
  export function useHydraClearThreadMessages(): (
    threadId: string,
  ) => Promise<void>;
  export function useHydraArchiveThread(): (threadId: string) => Promise<void>;

  // Configuration hooks
  export function useHydraUpdateSystemMessage(): (
    message: string,
  ) => Promise<void>;
  export function useHydraUpdatePrompt(): (prompt: string) => Promise<void>;
  export function useHydraSystemConfig(): {
    systemMessage: string | undefined;
    prompt: string | undefined;
    updateSystemMessage: (message: string) => Promise<void>;
    updatePrompt: (prompt: string) => Promise<void>;
  };

  // Specialized hooks (common patterns)
  export function useHydraThreadMessages(threadId: string): HydraThreadMessages;
  export function useHydraThreadComponent(
    messageId: string,
  ): HydraThreadComponent;

  // Suggestion handling types
  export interface SuggestionHandlers {
    accept: (suggestion: HydraSuggestion) => Promise<void>;
    dismiss: (suggestion: HydraSuggestion) => Promise<void>;
    getSuggestions: () => HydraSuggestion[];
  }

  // Add specialized suggestion hook
  export function useThreadSuggestions(threadId: string): {
    suggestions: HydraSuggestion[];
    accept: (suggestion: HydraSuggestion) => Promise<void>;
    dismiss: (suggestion: HydraSuggestion) => Promise<void>;
  };

  // Add Personality types
  export interface HydraPersonality {
    role: string;
    style: string;
    rules: string[];
  }

  // Update HydraContext
  export interface HydraContext {
    config: HydraInitConfig<any>;
    updateSystemMessage: (message: string) => Promise<void>;
    updatePrompt: (prompt: string) => Promise<void>;
    updatePersonality: (personality: HydraPersonality) => Promise<void>;
    updatePersonalityField: (
      field: keyof HydraPersonality,
      value: string | string[],
    ) => Promise<void>;
  }

  export function useHydraContext(): HydraContext | null;

  // Profile Management
  export interface HydraStoredProfile {
    userId: string;
    profile: string;
    updatedAt: string;
  }

  export interface HydraProfileOperations {
    getProfile: (userId: string) => Promise<HydraStoredProfile | null>;
    updateProfile: (userId: string, profile: string) => Promise<void>;
    deleteProfile: (userId: string) => Promise<void>;
    listProfiles: () => Promise<HydraStoredProfile[]>;
  }

  // Profile hooks
  export function useHydraProfile(userId: string): {
    profile: HydraStoredProfile | null;
    isLoading: boolean;
    error: Error | null;
    updateProfile: (profile: string) => Promise<void>;
    deleteProfile: () => Promise<void>;
  };

  export function useHydraProfileOperations(): HydraProfileOperations;

  export function useHydraProfiles(): {
    profiles: HydraStoredProfile[];
    isLoading: boolean;
    error: Error | null;
    refresh: () => Promise<void>;
  };

  // Add new hooks
  export function useUpdatePersonality(): (
    personality: HydraPersonality,
  ) => Promise<void>;
  export function usePersonalityField(
    field: keyof HydraPersonality,
  ): (value: string | string[]) => Promise<void>;
  export function usePersonality(): {
    personality: HydraPersonality | undefined;
    updatePersonality: (personality: HydraPersonality) => Promise<void>;
    updateField: (
      field: keyof HydraPersonality,
      value: string | string[],
    ) => Promise<void>;
  };
}
