# Component State Management Approaches

> **Selected Approach: Context-Based Auto Wrapper**
>
> After evaluating all options, we chose the Context-based approach because:
>
> - Most idiomatic React pattern (uses modern React features and patterns)
> - Clearest mental model for component state management
> - Avoids lifecycle issues present in cloneElement approaches
> - No "magic" naming conventions or proxies
> - Explicit opt-in without excessive boilerplate
> - Better TypeScript support and type inference
> - Easier to debug and test
>
> Key benefits over other approaches:
>
> - Unlike HOCs/Decorators: Follows modern React patterns
> - Unlike cloneElement: Avoids double-rendering and lifecycle issues
> - Unlike Proxy: No magic naming conventions
> - Unlike Registry: More flexible and easier to understand

This document outlines different approaches for managing Hydra component state and automatically generating wrapper components.

## Overview

Currently, Hydra components follow a two-part pattern:

1. Base Component: Pure React component with props interface
2. Hydra Wrapper: Connected version that handles state management

The goal is to simplify this pattern and reduce boilerplate while maintaining type safety and flexibility.

## Approaches

### 1. Higher-Order Component (HOC) Factory

```typescript
const withHydra = (BaseComponent) => {
  return ({ messageId, ...props }) => {
    const { interactiveProps, updateInteractiveProps } = useHydraComponentState(messageId);
    return <BaseComponent {...interactiveProps} {...props} onChange={updateInteractiveProps} />;
  };
}

// Usage
const HydraNoteComponent = withHydra(NoteComponent);
```

### 2. Generic Message Wrapper Component

```typescript
const HydraMessage = ({ messageId, children, component: Component }) => {
  const { interactiveProps, updateInteractiveProps } = useHydraComponentState(messageId);
  return React.cloneElement(children, {
    ...interactiveProps,
    onChange: updateInteractiveProps
  });
};

// Usage
<HydraMessage messageId={messageId}>
  <NoteComponent />
</HydraMessage>
```

### 3. Component Registry Auto-Wrapper

```typescript
const createComponentRegistry = (components) => {
  return Object.entries(components).reduce((acc, [name, config]) => {
    const wrapped = ({ messageId, ...props }) => {
      const { interactiveProps, updateInteractiveProps } = useHydraComponentState(messageId);
      return <config.component {...interactiveProps} {...props} onChange={updateInteractiveProps} />;
    };
    return { ...acc, [name]: { ...config, wrappedComponent: wrapped }};
  }, {});
};
```

### 4. Proxy-based Auto Wrapper

```typescript
const createHydraComponentProxy = (components) => {
  return new Proxy(components, {
    get: (target, prop) => {
      if (prop.startsWith('Hydra')) {
        const baseComponent = target[prop.replace('Hydra', '')];
        return ({ messageId, ...props }) => {
          const { interactiveProps, updateInteractiveProps } = useHydraComponentState(messageId);
          return <baseComponent {...interactiveProps} {...props} onChange={updateInteractiveProps} />;
        };
      }
      return target[prop];
    }
  });
};
```

### 5. Decorator Pattern

```typescript
const hydraComponent = (options = {}) => {
  return (WrappedComponent) => {
    return ({ messageId, ...props }) => {
      const { interactiveProps, updateInteractiveProps } = useHydraComponentState(messageId);
      return <WrappedComponent {...interactiveProps} {...props} onChange={updateInteractiveProps} />;
    };
  };
};

// Usage
@hydraComponent()
class MyComponent extends React.Component { ... }
```

### 6. Context-Based Auto Wrapper

```typescript
const HydraMessageContext = ({ messageId, children }) => {
  const { interactiveProps, updateInteractiveProps } = useHydraComponentState(messageId);

  return (
    <HydraContext.Provider value={{ interactiveProps, updateInteractiveProps }}>
      {children}
    </HydraContext.Provider>
  );
};

// Components opt-in to Hydra state
const useHydraAware = (Component) => {
  const hydraContext = useContext(HydraContext);
  return hydraContext ? withHydra(Component) : Component;
};
```

## Comparison Table

| Approach                | Pros                                                                                                  | Cons                                                                                                 | Best For                                                                              |
| ----------------------- | ----------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| HOC Factory             | - Simple implementation<br/>- Clear composition<br/>- Explicit wrapping<br/>- Good TypeScript support | - Requires manual wrapping<br/>- Wrapper hell with multiple HOCs<br/>- Props pass-through complexity | - Small to medium projects<br/>- Teams that prefer explicit over implicit             |
| Generic Message Wrapper | - Flexible usage<br/>- Matches React patterns<br/>- Easy to understand<br/>- No build config needed   | - Slightly more verbose JSX<br/>- Potential prop drilling<br/>- Clone element limitations            | - Most React projects<br/>- Teams familiar with React patterns                        |
| Registry Auto-Wrapper   | - Automatic wrapping<br/>- Centralized configuration<br/>- Good for large component sets              | - Less flexible<br/>- More complex implementation<br/>- Harder to customize per-use                  | - Large applications<br/>- Enterprise systems<br/>- Consistent component patterns     |
| Proxy-based             | - Very automatic<br/>- Minimal boilerplate<br/>- Dynamic component creation                           | - "Magic" behavior<br/>- Harder to debug<br/>- TypeScript challenges                                 | - Advanced developers<br/>- Performance-critical apps<br/>- Complex component systems |
| Decorator Pattern       | - Clean syntax<br/>- Class component friendly<br/>- Good for TypeScript                               | - Requires build config<br/>- Experimental feature<br/>- Less common in React                        | - TypeScript projects<br/>- Teams using decorators<br/>- Class components             |
| Context-Based           | - React idiomatic<br/>- Flexible opt-in<br/>- Good state sharing                                      | - More boilerplate<br/>- Context overhead<br/>- Potential re-render issues                           | - Complex state needs<br/>- Nested components<br/>- Modern React apps                 |

## Recommendations

### For Small to Medium Projects

Use the **Generic Message Wrapper** or **HOC Factory** approach. These are:

- Easier to understand and maintain
- More explicit in their behavior
- Require minimal setup

### For Large Enterprise Projects

Consider the **Registry Auto-Wrapper** or **Context-Based** approach. These provide:

- Better scalability
- More consistent patterns
- Better state management for complex apps

### For Performance-Critical Applications

The **Proxy-based** or optimized **HOC Factory** approaches might be best, offering:

- Minimal runtime overhead
- Efficient component creation
- Better memory usage

## Implementation Considerations

1. **Type Safety**

   - All approaches should maintain strict TypeScript types
   - Consider using generics for better type inference
   - Validate props at runtime with Zod schemas

2. **Performance**

   - Minimize unnecessary re-renders
   - Consider memoization where appropriate
   - Be cautious with context in performance-critical sections

3. **Developer Experience**

   - Provide clear error messages
   - Add development-time validation
   - Include comprehensive TypeScript types

4. **Testing**
   - Each approach needs different testing strategies
   - Consider mocking strategies for each pattern
   - Test both wrapped and unwrapped components

## Future Considerations

- Integration with React Server Components
- Support for concurrent rendering
- Potential React 19+ features
- Build tool optimizations
