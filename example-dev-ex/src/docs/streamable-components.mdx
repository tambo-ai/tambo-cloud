# Streamable Components

## Core Concepts

### 1. Basic Streaming

```tsx
import { useComponentStream } from "hydra-ai-react";
import { z } from "zod";

const Schema = z.object({
  content: z.string(),
  complete: z.boolean(),
});

function BasicStream() {
  const { data, loading } = useComponentStream({
    schema: Schema,
    streaming: true, // Stream all fields
  });

  return loading ? <LoadingIndicator /> : <Content value={data?.content} />;
}
```

### 2. Progressive Values

```tsx
const ProgressiveSchema = z.object({
  text: z.string(), // Will stream as: "Hello..." -> "Hello world"
  email: z.string().email(), // Will stream as: "user@" -> "user@example.com"
  content: z.object({
    value: z.string(),
    confidence: z.number(),
    complete: z.boolean(),
  }),
});

function ProgressiveForm() {
  const { data, isComplete } = useComponentStream({
    schema: ProgressiveSchema,
    streaming: ["text", "email", "content"], // Stream specific fields
  });

  return (
    <div>
      <p>{data?.text}</p>
      {data?.email && <p>Email: {data.email}</p>}

      {data?.content && (
        <div>
          <p>{data.content.value}</p>
          <p>Confidence: {data.content.confidence * 100}%</p>
          <p>Status: {data.content.complete ? "Done" : "Processing"}</p>
        </div>
      )}
    </div>
  );
}
```

### 3. Field-by-Field Rendering

```tsx
const EmailSchema = z.object({
  subject: z.string(),
  body: z.string(),
  recipients: z.array(z.string()),
  priority: z.enum(["high", "normal", "low"]),
});

function FieldByFieldEmail() {
  const { data, isFieldComplete } = useComponentStream({
    schema: EmailSchema,
    streaming: ["subject", "body"], // Only stream content fields
  });

  return (
    <div className="email">
      {isFieldComplete("subject") && <h1>{data.subject}</h1>}
      {isFieldComplete("recipients") && (
        <div>
          {data.recipients.map((r) => (
            <Chip key={r} label={r} />
          ))}
        </div>
      )}
      {isFieldComplete("body") && <div>{data.body}</div>}
      {isFieldComplete("priority") && <PriorityBadge level={data.priority} />}
    </div>
  );
}
```

### 4. Mixed Streaming Strategies

```tsx
const MixedSchema = z.object({
  metadata: z.object({
    author: z.string(),
    date: z.string(),
  }),
  content: z.object({
    title: z.string(),
    body: z.string(),
  }),
  comments: z.array(
    z.object({
      id: z.string(),
      text: z.string(),
    })
  ),
});

function MixedDocument() {
  const { data, isComplete, isFieldComplete } = useComponentStream({
    schema: MixedSchema,
    // Stream nested fields
    streaming: ["content.title", "content.body"],
  });

  return (
    <article>
      {isFieldComplete("metadata") && (
        <header>
          <Author name={data.metadata.author} />
          <Time date={data.metadata.date} />
        </header>
      )}

      <div className="content">
        <h1>
          {data?.content?.title}
          {!isComplete("content.title") && <Cursor />}
        </h1>
        <div className="body">
          {data?.content?.body}
          {!isComplete("content.body") && <Cursor />}
        </div>
      </div>

      <div className="comments">
        {data?.comments?.map((comment) => (
          <Comment key={comment.id} text={comment.text} />
        ))}
      </div>
    </article>
  );
}
```

## Integration Patterns

### State Management Integration

```tsx
import { useHydraMessage, useComponentStream } from "hydra-ai-react";
import { z } from "zod";

const EmailSchema = z.object({
  subject: z.string(),
  content: z.string(),
});

function StatefulStreamingEmail() {
  const [message, setMessage] = useHydraMessage<EmailData>();
  const { data, isPathComplete, startStream } = useComponentStream({
    schema: EmailSchema,
    streaming: { paths: ["subject", "content.body"] },
    onFieldComplete: (field, value) =>
      setMessage((prev) => ({ ...prev, [field]: value })),
  });

  return (
    <form>
      <button onClick={startStream}>Start</button>
      <input
        value={data?.subject || message.subject || ""}
        aria-busy={!isPathComplete(["subject"])}
      />
      <textarea
        value={data?.content?.body || message.content?.body || ""}
        aria-busy={!isPathComplete(["content", "body"])}
      />
    </form>
  );
}
```

### Thread System Integration

```tsx
import { useThreadMessages, useComponentStream } from "hydra-ai-react";
import { useDebouncedCallback } from "use-debounce";

function ThreadStreamingDocument() {
  const { messages, updateThread } = useThreadMessages(threadId);
  const { data, isComplete, startStream } = useComponentStream({
    schema: DocumentSchema,
    streaming: { paths: ["content.*", "metadata"] },
    onComplete: (data) => updateThread(messageId, data),
  });

  return (
    <div role="log">
      <button onClick={() => startStream({ threadId, messageId })}>
        Process Document
      </button>
      <DocumentDisplay data={data} isLoading={!isComplete} />
      <ThreadMessageList messages={messages} />
    </div>
  );
}

const ThreadMessageList = memo(({ messages }) => (
  <ul>
    {messages.map((msg) => (
      <Message key={msg.id} {...msg} />
    ))}
  </ul>
));
```

### Component State Integration

```tsx
import { useThreadComponent, useComponentStream } from "hydra-ai-react";
import { useDebouncedCallback } from "use-debounce";

function ComponentStateExample() {
  const { props, updateProps } = useThreadComponent(messageId);
  const { data, status, startStream } = useComponentStream({
    schema: Schema,
    streaming: { paths: ["title", "content.*"] },
    onFieldComplete: (field, value) => {
      if (field === "title") updateProps({ title: value });
    },
  });

  return (
    <div>
      <button
        onClick={() => startStream({ componentId: props.id })}
        disabled={status === "streaming"}
      >
        Update
      </button>
      <Component {...props} streamingData={data} />
      <StreamingStatus paths={["title", "content"]} status={status} />
    </div>
  );
}
```
