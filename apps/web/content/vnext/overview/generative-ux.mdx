---
title: Generative UX
description: Building dynamic interfaces with Tambo AI components.
---

Tambo AI enables you to create dynamic interfaces by orchestrating your React components. This guide will show you how to build components that work seamlessly with Tambo.

We'll cover two main approaches:

- Display only components
- Interactive components

## Why make components interactive?

Let's say the user updates a component text value, and then ask your AI assistant can you edit the text. Tambo will use the same state of the component in the follow up message as context!

Our react hooks give yous out of the box:

- Persistence
- Type safety
- Inclusion in subsequent messages

With no extra work on your part!

## Simple Display Components

This is the simplest form of component. It takes in props and displays data.

```tsx title="Simple Data Display"
const DataDisplay = ({ data }) => (
  <table>
    <thead>
      <tr>
        {Object.keys(data[0]).map((key) => (
          <th key={key}>{key}</th>
        ))}
      </tr>
    </thead>
    <tbody>
      {data.map((row, i) => (
        <tr key={i}>
          {Object.values(row).map((value, j) => (
            <td key={j}>{value}</td>
          ))}
        </tr>
      ))}
    </tbody>
  </table>
);

const DataDisplayDefinition = {
  component: DataDisplay, // [!code focus]
  propsSchema: z.object({
    data: z.array(z.record(z.string(), z.unknown())),
  }),
  description: "Display data in a table format",
};
```

### Interactive Components

This is a little more complex. It takes in props and displays data. It also has a state that can be updated.

But we provide you with hooks to manage the state and validation that make it easy to create interactive components, with persistence, validation, and inclusion in subsequent messages.

The `useTamboComponentState` hook is used to manage the state of the component. It functions similarly to the `useState` hook, but it also includes persistence, validation, and inclusion in subsequent messages. Unlike `useState`, you must name the state key, so that it is consistent across future renders in the same component.

The state will be persisted for in specific component instance, even when the page reloads.

```tsx title="Interactive Data Table"
const InteractiveTable = ({ data }) => {
  const [filterState, setFilterState] =
    useTamboComponentState<TableFilters>("table-filters");

  const filters = filterState?.filters ?? {};

  const handleFilter = (column, columnFilterValue) => {
    updateFilterState({ ...filters, [column]: columnFilterValue });
  };

  const columns = Object.keys(data[0]);

  return (
    <>
      <div>
        {columns.map((col) => (
          <input
            key={col}
            placeholder={col}
            onChange={(e) => handleFilter(col, e.target.value)}
            value={filters[col] || ""}
          />
        ))}
      </div>
      <table>
        <thead>
          <tr>
            {columns.map((col) => (
              <th key={col}>{col}</th>
            ))}
          </tr>
        </thead>
        <tbody>
          {data.map((row, i) => (
            <tr key={i}>
              {columns.map((col) => (
                <td key={col}>{row[col]}</td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
    </>
  );
};

const InteractiveTableDefinition = {
  component: InteractiveTable,
  propsSchema: z.object({
    data: z.array(z.record(z.string(), z.unknown())),
  }),
  description: "Interactive table with filtering",
};
```

## Need another example?

Here is a form component that has a state that can be updated.

**What's happening here?**

- We're using the `useTamboComponentState` hook to manage the state of the form.

```tsx title="Simple Form"
const Form = ({ fields }: { fields: { name: string; type: string }[] }) => {
  const [formValue, setFormValue] =
    useTamboComponentState<SimpleFormState>("form-value");
  const formData = formValue?.data ?? {};

  const handleSubmit = (e) => {
    e.preventDefault();
    setFormValue({ ...formValue, submitted: true });
  };

  return (
    <form onSubmit={handleSubmit}>
      {fields.map(({ name, type }) => (
        <div key={name}>
          <label>{name}</label>
          <input
            type={type}
            value={formData[name] || ""}
            onChange={(e) =>
              setFormValue({
                ...formValue,
                data: { ...formData, [name]: e.target.value },
              })
            }
          />
        </div>
      ))}
      <button type="submit">Submit</button>
    </form>
  );
};

const FormDefinition = {
  component: Form,
  propsSchema: z.object({
    fields: z.array(
      z.object({
        name: z.string(),
        type: z.string(),
      }),
    ),
  }),
  description: "Interactive form with state management",
};
```

Looking for streaming?

<Cards>
  <Card href="/vnext/overview/streaming" title="Streaming Overview">
    Learn more about how to make your interface feel more responsive with
    streaming
  </Card>
</Cards>
